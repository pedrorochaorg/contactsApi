
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/pedrorochaorg/contactsApi/api/api.go (0.0%)</option>
				
				<option value="file1">github.com/pedrorochaorg/contactsApi/api/objects.go (100.0%)</option>
				
				<option value="file2">github.com/pedrorochaorg/contactsApi/api/users.go (0.0%)</option>
				
				<option value="file3">github.com/pedrorochaorg/contactsApi/db/database.go (100.0%)</option>
				
				<option value="file4">github.com/pedrorochaorg/contactsApi/obj/contact.go (100.0%)</option>
				
				<option value="file5">github.com/pedrorochaorg/contactsApi/obj/user.go (100.0%)</option>
				
				<option value="file6">github.com/pedrorochaorg/contactsApi/repos/users.go (97.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "context"
        "database/sql"
        "encoding/json"
        "log"
        "net/http"

        "github.com/pedrorochaorg/contactsApi/db"
        "github.com/pedrorochaorg/contactsApi/repos"
)

const (
        ContentReady     = string("Content Ready")
        ErrNotFound     = string("Page not found")
        JsonContentType = "application/json"
)

type API struct {
        db *sql.DB
        http.Handler
}

func NewAPI(db *sql.DB) *API <span class="cov0" title="0">{
        handler := new(API)

        handler.db = db

        initDB(db)

        router := http.NewServeMux()

        repository := repos.NewUserRepository(db)
        router.Handle("/users/", NewUserHandler(&amp;repository))


        handler.Handler = router
        return handler
}</span>

func initDB(database *sql.DB) <span class="cov0" title="0">{

        log.Println("Initializing database")
        for _, stmt := range db.InitStatements </span><span class="cov0" title="0">{
                _, err := database.ExecContext(context.Background(), stmt)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to execute statement in database: %s, %s", stmt, err)
                }</span>
        }

}


// FailureReply method that encodes a notFoundReply to
func FailureReply(er *Error ,w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        log.Printf("Path: %s, Method: %s, Msg: %s, Status: %d", r.URL.Path, r.Method, er.msg, er.status)

        w.Header().Set("content-type", JsonContentType)
        w.WriteHeader(er.status)

        response := Response{
                Status:  false,
                Message: er.msg,
                Result:  nil,
        }

        err := json.NewEncoder(w).Encode(response)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                log.Fatalf("Failed to encode object %v", response)
                return
        }</span>
}


func SuccessReply(data *Data, w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        log.Printf("Path: %s, Method: %s, Msg: %s, Status: %d", r.URL.Path, r.Method, data.message, data.status)

        w.Header().Set("content-type", JsonContentType)
        w.WriteHeader(data.status)

        response := Response{
                Status:  true,
                Message: data.message,
                Result:  data.data,
        }

        err := json.NewEncoder(w).Encode(response)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                log.Fatalf("Failed to encode object %v", response)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "fmt"
        "net/http"
        "reflect"
        "strings"
)

type Handler struct {
        path           string
        handler        func(w http.ResponseWriter, r UrlRequest)
        method         string
        pathSliced     []string
        pathVars       []string
        pathWithoutVars []string
        pathVarIndexes pathParamsIndexes
}

type Handlers []Handler

// Add's a handler struct to a slice of handlers spliting the path in the character '/'
func (h *Handlers) Add(path, method string,fn func(w http.ResponseWriter, r UrlRequest)) <span class="cov8" title="1">{

        if strings.Index(path, "/") == 0 </span><span class="cov8" title="1">{
                path = path[1:]
        }</span>

        <span class="cov8" title="1">if len(path) &gt; 1 &amp;&amp; strings.LastIndex(path, "/") == (len(path) - 1) </span><span class="cov8" title="1">{
                path = path[0:len(path)-1]
        }</span>

        <span class="cov8" title="1">if path == "" </span><span class="cov8" title="1">{
                *h = append(*h, Handler{
                        path: path,
                        handler: fn,
                        method: method,
                })
        }</span>

        // Slices the path string when it find's the char '/'
        <span class="cov8" title="1">pathSliced := strings.Split(path, "/")

        // Returns 3 slices each of of them containing: a slice containing the path parameters excluding the
        // variable placeholders; the index of each variable placeholder in the pathSliced slice; a slice
        // containing the name of each variable found in the pathSliced slice ( the value between the characters '{}' )
        pathWithoutVars, pathVarIndexes, pathVars := splitVarsFromStaticPathParameters(pathSliced)


        *h = append(*h, Handler{
                path,
                fn,
                method,
                pathSliced,
                pathVars,
                pathWithoutVars,
                pathVarIndexes,
        })</span>
}

type VarsHandler struct {
        H    *Handler
        Vars map[string]string
}

type UrlRequest struct {
        R    *http.Request
        Vars map[string]string
}

type Error struct {
        msg    string
        status int
}

func (e Error) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s", e.msg)
}</span>

type Data struct {
        status  int
        message string
        data    interface{}
}

type pathParamsIndexes []int

// Returns the index of the slice position of a value.
// This function will return the value of -1 if the slice of int's doesn't contain the value that we used to call it
func (e pathParamsIndexes) Contains(val int) int <span class="cov8" title="1">{
        for i, v := range e </span><span class="cov8" title="1">{
                if v == val </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// GetByMethodAndType returns the handler that matches the url and the http request method being sent by the user,
// the path string may contain variables identified by a start character and an end character,
// this characters are '{' and '}' respectively.
// This method returns an 'Error' object in case of not finding any handler that matches our path url or the an
// VarsHandler object that contains the handler that matches the url and the http request method in the property 'H
// ' and a map of type key-&gt;string and value-&gt;string containing the variables that the matching url should contain.
// For instance if we call this method with a path value '/28/contacts/1' and we have a Handler whose path value is
// '/{id}/contacts/{contactId} this method will return a VarsHandler object with property 'H' having the matching
// hanlder object and the property 'Vars' a map with {"id": 28, "contactId": 1}
func (h Handlers) GetByMethodAndType(path, method string) (*VarsHandler, *Error) <span class="cov8" title="1">{

        if strings.Index(path, "/") == 0 </span><span class="cov8" title="1">{
                path = path[1:]
        }</span>

        <span class="cov8" title="1">if len(path) &gt; 1 &amp;&amp; strings.LastIndex(path, "/") == (len(path) - 1) </span><span class="cov8" title="1">{
                path = path[0:len(path)-1]
        }</span>

        // split's the path string in a slice ,
        // if the path string contains a value of 'users/list' the slicedPath should contain a slice of {"users", "list"}
        <span class="cov8" title="1">slicedPath := strings.Split(path, "/")

        // Loops through all Handler objects
        for _, handler := range h </span><span class="cov8" title="1">{

                // If the handler property path value is equal to the value of the path arg and the handler method value is
                // equal to the method arg,
                // means that we already found the handler that we were looking for and we should return that handler inside
                // of a VarsHandler struct.
                if handler.path == path &amp;&amp; handler.method == method </span><span class="cov8" title="1">{
                        return &amp;VarsHandler{H: &amp;handler}, nil
                }</span>

                // If the value of path property inside our handler doesn't contain a single character equal to '{' means
                // that this handler contains a simple and straight forward path and we should skip the next check
                <span class="cov8" title="1">if len(handler.pathVars) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check's the handler path,
                // splitting the handler path into a slice using the substring '/' and comparing it's length with the length
                // of the slicedPath arg. If the length is the same starts by removing the variables from the sliced
                // handler Path parameters and the value off the matching slice position of the slicedPath  slice.
                // Then it will extract the variables values identified in the handler path string from the slicedPath slice
                // and returns the actualPath without the variable values that matched the position of the handler variable
                // placeholders and a map containing a set of key/value pairs of the variable names and values extracted
                // from the originalPathString and from the handler path string.
                <span class="cov8" title="1">actualCleanPaths, handlerCleanPaths, vars, ok := verifyPathMatchingAndReturnPathParameterVariables(handler,
                        slicedPath)

                // The verifyPathMatchingAndReturnPathParameterVariables should return a non ok value if the slicedPath len
                // doesn't match to len of the slice that will be generated after splitting the handler path value when the
                // char '/' is found in it, if the len's doen't match we should proceed to testing the next handler.
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Compares both slice objects and if they are deeply equal and the method is the same we should return this
                // handler.
                <span class="cov8" title="1">if reflect.DeepEqual(actualCleanPaths, handlerCleanPaths) &amp;&amp; handler.method == method </span><span class="cov8" title="1">{
                        return &amp;VarsHandler{H: &amp;handler, Vars: vars}, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, &amp;Error{ErrNotFound, http.StatusNotFound}</span>
}

// Verifies if the number of path parameters present in the request path matches with the number of path parameters
// of an handler
func verifyPathMatchingAndReturnPathParameterVariables(handler Handler, originalSlicedPath []string) ([]string,
        []string,
        map[string]string, bool) <span class="cov8" title="1">{

        // If the length of the original originalSlicedPath doesn't match with the length of handler.pathSliced means that
        // this handler is not the handler that we are looking for and we should return false in the last return value
        if len(originalSlicedPath) != len(handler.pathSliced) </span><span class="cov8" title="1">{
                return nil, nil, nil, false
        }</span>

        <span class="cov8" title="1">originalPathWithoutValuesThatMatchVarIndexes := []string{}
        vars := map[string]string{}

        // Loops throught all path parameters of the original url
        for i, path := range originalSlicedPath </span><span class="cov8" title="1">{

                // Checks if the handler contains a variable in the same index that this path parameter is located,
                // and if it don't add's the path parameter to the originalPathWithoutValuesThatMatchVarIndexes slice.
                index := handler.pathVarIndexes.Contains(i)
                if index == -1 </span><span class="cov8" title="1">{
                        originalPathWithoutValuesThatMatchVarIndexes = append(originalPathWithoutValuesThatMatchVarIndexes, path)
                        continue</span>
                }
                // If the path parameter index is equal to the index value of variable of the handler path property ,
                // stores the variable value in the vars map obtaining the variable name from the handler.pathVars[index] slice
                // using the previous obtained index.
                <span class="cov8" title="1">vars[handler.pathVars[index]] = path</span>
        }

        // returns the originalPathWithoutValuesThatMatchVarIndexes slice, the handler.pathWithoutVars slice ,
        // the variables map containing the variables names and values and a status of true.
        <span class="cov8" title="1">return originalPathWithoutValuesThatMatchVarIndexes, handler.pathWithoutVars, vars, true</span>
}

// This method removes variables from handler path strings returning the handler path parameters that don't contain
// variables, the variables removed and the slice indexes were these values were located.
func splitVarsFromStaticPathParameters(splitedPath []string) (handlerPathWithoutVars []string,
        handlerPathVarIndexes pathParamsIndexes, handlerPathVarNames []string) <span class="cov8" title="1">{

        // Loops through all slices of the resulting string split executed on the handlerPath content
        for i, path := range splitedPath </span><span class="cov8" title="1">{
                if len(path) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // If the path slice start's and end's with '{' and '}' respectively,
                // means that this path parameter is a variable and we should store the index of the path parameter in a
                // slice and store the string that is between the same characters as a var name/id.
                <span class="cov8" title="1">if path[len(path)-1:] == "}" &amp;&amp; path[0:1] == "{" </span><span class="cov8" title="1">{
                        handlerPathVarIndexes = append(handlerPathVarIndexes, i)
                        handlerPathVarNames = append(handlerPathVarNames, path[1:len(path)-1])
                        continue</span>
                }
                // If the path parameter is not a variable we shoudl append it to a slice that will contains all path
                // parameters that aren't variables.
                <span class="cov8" title="1">handlerPathWithoutVars = append(handlerPathWithoutVars, path)</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "encoding/json"
        "log"
        "net/http"
        "strconv"

        "github.com/pedrorochaorg/contactsApi/obj"
        "github.com/pedrorochaorg/contactsApi/repos"
)

const (
        UserCreatedSuccessfully  = "User successfully created!"
        UserUpdatedSuccessfully  = "User successfully updated!"
        UserDeletedSuccessfully  = "User successfully deleted!"
        BadIdFormat  = "Bad id format!"
        UserNotFound  = "User not found!"
)

type UserHandler struct {
        repo repos.UserRepo
        *http.ServeMux
        handlers Handlers
}

func NewUserHandler(db repos.UserRepo) *UserHandler <span class="cov0" title="0">{
        handler := new(UserHandler)

        handler.repo = db

        handler.handlers = Handlers{}

        handler.handlers.Add("", http.MethodGet, handler.listUsers)
        handler.handlers.Add("", http.MethodPost, handler.createUser)
        handler.handlers.Add("/{id}", http.MethodGet, handler.getUser)
        handler.handlers.Add("/{id}", http.MethodPut, handler.updateUser)
        handler.handlers.Add("/{id}", http.MethodDelete, handler.deleteUser)
        handler.handlers.Add("/{id}/contacts", http.MethodGet, handler.getUserContacts)
        handler.handlers.Add("/{userId}/contacts/{id}", http.MethodGet, handler.getUserContacts)
        handler.handlers.Add("/{userId}/shit/{id}", http.MethodGet, handler.getUserContacts)

        log.Println(handler.handlers)

        return handler
}</span>

func (u *UserHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        subPath := r.URL.Path[len("/users/"):]

        if subPath[len(subPath)-1:] == "/" </span><span class="cov0" title="0">{
                subPath = subPath[:len(subPath)-1]
        }</span>

        <span class="cov0" title="0">httpMethod := r.Method

        handler, err := u.handlers.GetByMethodAndType(subPath, httpMethod)

        if err != nil </span><span class="cov0" title="0">{
                FailureReply(err, w, r)
                return
        }</span>

        <span class="cov0" title="0">handler.H.handler(w, UrlRequest{R: r, Vars: handler.Vars})</span>

}

func (u *UserHandler) listUsers(w http.ResponseWriter, r UrlRequest) <span class="cov0" title="0">{

        users, err := u.repo.List(r.R.Context())
        if err != nil </span><span class="cov0" title="0">{
                FailureReply(&amp;Error{msg: err.Error(), status: 500}, w, r.R)
                return
        }</span>

        <span class="cov0" title="0">SuccessReply(
                &amp;Data{status: 200, message: ContentReady, data: users},
                w,
                r.R,
        )</span>

}

func (u *UserHandler) createUser(w http.ResponseWriter, r UrlRequest) <span class="cov0" title="0">{
        user := obj.User{}
        err := json.NewDecoder(r.R.Body).Decode(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                FailureReply(&amp;Error{msg: err.Error(), status: 500}, w, r.R)
                return
        }</span>

        <span class="cov0" title="0">finalUser, err := u.repo.Create(r.R.Context(), &amp;user)
        if err != nil </span><span class="cov0" title="0">{
                FailureReply(&amp;Error{msg: err.Error(), status: 500}, w, r.R)
                return
        }</span>

        <span class="cov0" title="0">SuccessReply(
                &amp;Data{status: http.StatusCreated, message: UserCreatedSuccessfully, data: finalUser},
                w,
                r.R,
        )</span>

}

func (u *UserHandler) getUser(w http.ResponseWriter, r UrlRequest) <span class="cov0" title="0">{

        userId, err := strconv.Atoi(r.Vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                        FailureReply(&amp;Error{msg: BadIdFormat, status: 400}, w, r.R)
                        return
        }</span>

        <span class="cov0" title="0">user, err := u.repo.Get(r.R.Context(), int64(userId))
        if err != nil </span><span class="cov0" title="0">{
                FailureReply(&amp;Error{msg: UserNotFound, status: 404}, w, r.R)
                return
        }</span>

        <span class="cov0" title="0">SuccessReply(
                &amp;Data{status: http.StatusOK, message: ContentReady, data: user},
                w,
                r.R,
        )</span>
}


func (u *UserHandler) updateUser(w http.ResponseWriter, r UrlRequest) <span class="cov0" title="0">{

        userId, err := strconv.Atoi(r.Vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                FailureReply(&amp;Error{msg: BadIdFormat, status: 400}, w, r.R)
                return
        }</span>

        <span class="cov0" title="0">user, err := u.repo.Get(r.R.Context(), int64(userId))
        if err != nil </span><span class="cov0" title="0">{
                FailureReply(&amp;Error{msg: UserNotFound, status: 404}, w, r.R)
                return
        }</span>

        <span class="cov0" title="0">updatedUser := obj.User{}
        err = json.NewDecoder(r.R.Body).Decode(&amp;updatedUser)
        if err != nil </span><span class="cov0" title="0">{
                FailureReply(&amp;Error{msg: err.Error(), status: 500}, w, r.R)
                return
        }</span>

        <span class="cov0" title="0">user.FirstName = updatedUser.FirstName
        user.LastName = updatedUser.LastName

        finalUser, err := u.repo.Update(r.R.Context(), user)
        if err != nil </span><span class="cov0" title="0">{
                FailureReply(&amp;Error{msg: err.Error(), status: 500}, w, r.R)
                return
        }</span>

        <span class="cov0" title="0">SuccessReply(
                &amp;Data{status: http.StatusAccepted, message: UserUpdatedSuccessfully, data: finalUser},
                w,
                r.R,
        )</span>

}


func (u *UserHandler) deleteUser(w http.ResponseWriter, r UrlRequest) <span class="cov0" title="0">{

        userId, err := strconv.Atoi(r.Vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                FailureReply(&amp;Error{msg: BadIdFormat, status: 400}, w, r.R)
                return
        }</span>

        <span class="cov0" title="0">_, err = u.repo.Get(r.R.Context(), int64(userId))
        if err != nil </span><span class="cov0" title="0">{
                FailureReply(&amp;Error{msg: UserNotFound, status: 404}, w, r.R)
                return
        }</span>

        <span class="cov0" title="0">_, err = u.repo.Delete(r.R.Context(), int64(userId))
        if err != nil </span><span class="cov0" title="0">{
                FailureReply(&amp;Error{msg: err.Error(), status: 400}, w, r.R)
                return
        }</span>

        <span class="cov0" title="0">SuccessReply(
                &amp;Data{status: http.StatusOK, message: UserDeletedSuccessfully, data: nil},
                w,
                r.R,
        )</span>

}


func (u *UserHandler) getUserContacts(w http.ResponseWriter, r UrlRequest) <span class="cov0" title="0">{

        userId, err := strconv.Atoi(r.Vars["userId"])
        if err != nil </span><span class="cov0" title="0">{
                FailureReply(&amp;Error{msg: BadIdFormat, status: 400}, w, r.R)
                return
        }</span>

        <span class="cov0" title="0">contactId, err := strconv.Atoi(r.Vars["id"])
        if err != nil </span><span class="cov0" title="0">{
                FailureReply(&amp;Error{msg: BadIdFormat, status: 400}, w, r.R)
                return
        }</span>

        <span class="cov0" title="0">log.Println("ContactId", contactId)

        user, err := u.repo.Get(r.R.Context(), int64(userId))
        if err != nil </span><span class="cov0" title="0">{
                FailureReply(&amp;Error{msg: UserNotFound, status: 404}, w, r.R)
                return
        }</span>

        <span class="cov0" title="0">SuccessReply(
                &amp;Data{status: http.StatusOK, message: ContentReady, data: user},
                w,
                r.R,
        )</span>
}

</pre>
		
		<pre class="file" id="file3" style="display: none">package db

import (
        "fmt"
        "sync"

        _ "github.com/lib/pq"
)

// Database struct that will would our database connection and the options that were used while connecting to this
// database.
type Database struct {
        mu sync.Mutex
        host string
        port string
        username string
        password string
        database string
        sslmode string
}


// ConnectionString returns a string reperesentation of the databaseOptions object and all it's property values,
// this string is used to establish the connection with the database server
func (d *Database) ConnectionString() string <span class="cov8" title="1">{
        return fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=%s", d.host, d.port, d.username,
                d.password, d.database, d.sslmode)
}</span>

// DatabaseOpts type func used to populate the databaseoptions struct with each property value implementing the
// Functional Options pattern
type DatabaseOpts func(d *Database)

// WithHost set's the value of the 'host' property value of the 'databaseOptions' struct
func WithHost(host string) DatabaseOpts <span class="cov8" title="1">{
        return func(d *Database) </span><span class="cov8" title="1">{
                d.host = host
        }</span>
}

// WithPort set's the value of the 'host' property value of the 'databaseOptions' struct
func WithPort(port string) DatabaseOpts <span class="cov8" title="1">{
        return func(d *Database) </span><span class="cov8" title="1">{
                d.port = port
        }</span>
}

// WithUsername set's the value of the 'username' property value of the 'databaseOptions' struct
func WithUsername(username string) DatabaseOpts <span class="cov8" title="1">{
        return func(d *Database) </span><span class="cov8" title="1">{
                d.username = username
        }</span>
}

// WithPassword set's the value of the 'password' property value of the 'databaseOptions' struct
func WithPassword(password string) DatabaseOpts <span class="cov8" title="1">{
        return func(d *Database) </span><span class="cov8" title="1">{
                d.password = password
        }</span>
}

// WithDatabase set's the value of the 'database' property value of the 'databaseOptions' struct
func WithDatabase(database string) DatabaseOpts <span class="cov8" title="1">{
        return func(d *Database) </span><span class="cov8" title="1">{
                d.database = database
        }</span>
}

// WithSslMode set's the value of the 'sslmode' property value of the 'databaseOptions' struct
func WithSslMode(sslmode string) DatabaseOpts <span class="cov8" title="1">{
        return func(d *Database) </span><span class="cov8" title="1">{
                d.sslmode = sslmode
        }</span>
}


func NewDatabaseConnection(opts ...DatabaseOpts) *Database <span class="cov8" title="1">{
        dbInstance := &amp;Database{}

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(dbInstance)
        }</span>

        <span class="cov8" title="1">return dbInstance</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package obj

import (
        "fmt"
        "time"
)

type Contact struct {
        ID        int64     `json:"id"`
        UserID    int64     `json:"user_id"`
        FirstName string    `json:"first_name"`
        LastName  string    `json:"last_name"`
        Email     string    `json:"email"`
        Phone     string    `json:"phone"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

func (c Contact) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("ID=%d UserID=%d FirstName=%s LastName=%s Email=%s Phone=%s CreatedAt=%s UpdatedAt=%s", c.ID,
                c.UserID,
                c.FirstName,
                c.LastName, c.Email, c.Phone, c.CreatedAt, c.UpdatedAt)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package obj

import (
        "fmt"
        "time"
)

type User struct {
        ID        int     `json:"id"`
        FirstName string    `json:"first_name"`
        LastName  string    `json:"last_name"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
        Contacts  []Contact `json:"contacts,omitempty"`
}

func (c User) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("ID=%d FirstName=%s LastName=%s CreatedAt=%s UpdatedAt=%s Contacts=%s", c.ID, c.FirstName,
                c.LastName, c.CreatedAt, c.UpdatedAt, c.Contacts)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package repos

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/pedrorochaorg/contactsApi/obj"
)

type UserRepo interface {
        List(ctx context.Context) ([]obj.User, error)
        Create(ctx context.Context, user *obj.User) (*obj.User, error)
        Update(ctx context.Context, user *obj.User) (*obj.User, error)
        Get(ctx context.Context, id int64) (*obj.User, error)
        Delete(ctx context.Context, id int64) (bool, error)
}

type UserRepository struct {
        db *sql.DB
}

// NewUserRepository instantiates a new user repository injecting the database connection interface as a dependency
func NewUserRepository(db *sql.DB) UserRepository <span class="cov8" title="1">{
        return UserRepository{db}
}</span>

// List return a set of users from database
func (u *UserRepository) List(ctx context.Context) ([]obj.User, error) <span class="cov8" title="1">{

        rows, err := u.db.QueryContext(ctx, "SELECT * FROM \"contactsApi\".\"users\"")
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to fetch users from database: %s", err)
        }</span>

        <span class="cov8" title="1">users := []obj.User{}

        defer rows.Close()
        for rows.Next() </span><span class="cov8" title="1">{
                user := obj.User{}
                err = rows.Scan(
                        &amp;user.ID,
                        &amp;user.FirstName,
                        &amp;user.LastName,
                        &amp;user.UpdatedAt,
                        &amp;user.CreatedAt)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to map row to user: %s", err)
                }</span>
                <span class="cov8" title="1">users = append(users, user)</span>
        }
        <span class="cov8" title="1">return users, nil</span>
}

// Creates a user in database
func (u *UserRepository) Create(ctx context.Context, user *obj.User) (*obj.User, error) <span class="cov8" title="1">{
        rows, err := u.db.QueryContext(ctx, "INSERT INTO \"contactsApi\".\"users\"(\"firstName\", "+
                "\"lastName\") VALUES($1,"+
                "$2) RETURNING *",
                user.FirstName, user.LastName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to fetch users from database: %s", err)
        }</span>

        <span class="cov8" title="1">defer rows.Close()
        rows.Next()
        err = rows.Scan(
                &amp;user.ID,
                &amp;user.FirstName,
                &amp;user.LastName,
                &amp;user.UpdatedAt,
                &amp;user.CreatedAt)

        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to map row to user: %s", err)
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

// Update
func (u *UserRepository) Update(ctx context.Context, user *obj.User) (*obj.User, error) <span class="cov8" title="1">{
        rows, err := u.db.QueryContext(ctx, "UPDATE \"contactsApi\".\"users\" SET \"firstName\" = $1, "+
                "\"lastName\" = $2 WHERE id = $3 RETURNING *",
                user.FirstName, user.LastName, user.ID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to fetch users from database: %s", err)
        }</span>

        <span class="cov8" title="1">defer rows.Close()
        rows.Next()
        err = rows.Scan(
                &amp;user.ID,
                &amp;user.FirstName,
                &amp;user.LastName,
                &amp;user.UpdatedAt,
                &amp;user.CreatedAt)

        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to map row to user: %s", err)
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

// Get
func (u *UserRepository) Get(ctx context.Context, id int64) (*obj.User, error) <span class="cov8" title="1">{
        rows, err := u.db.QueryContext(ctx, "SELECT * FROM \"contactsApi\".\"users\" WHERE id = $1", id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to fetch users from database: %s", err)
        }</span>

        <span class="cov8" title="1">user := &amp;obj.User{}

        defer rows.Close()

        rows.Next()
        err = rows.Scan(
                &amp;user.ID,
                &amp;user.FirstName,
                &amp;user.LastName,
                &amp;user.UpdatedAt,
                &amp;user.CreatedAt)

        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to map row to user: %s", err)
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

// Delete
func (u *UserRepository) Delete(ctx context.Context, id int64) (bool, error) <span class="cov8" title="1">{
        rows, err := u.db.ExecContext(ctx, "DELETE FROM \"contactsApi\".\"users\" WHERE id = $1", id)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("failed to fetch users from database: %s", err)
        }</span>

        <span class="cov8" title="1">_, err = rows.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to obtain the number of affected rows: %s", err)

        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
